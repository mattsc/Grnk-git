#textdomain wesnoth-Grnk

#define PLACE_AND_REMOVE_ITEM HALO X Y DELAY_TIME
    [item]
        x,y={X},{Y}
        halo={HALO}
    [/item]
    {DELAY {DELAY_TIME}}
    [remove_item]
        x,y={X},{Y}
        image={HALO}
    [/remove_item]
#enddef

#define REMOVE_AND_PLACE_ITEM HALO X Y DELAY_TIME
    [remove_item]
        x,y={X},{Y}
        image={HALO}
    [/remove_item]
    [item]
        x,y={X},{Y}
        halo={HALO}
    [/item]
    {DELAY {DELAY_TIME}}
#enddef

#define MOVE_UNIT_OFF_MAP_CORE ID FACING WML
    # Core macro for MOVE_UNIT_OFF_MAP and MOVE_UNIT_TO_EDGE_AND_OFF_MAP
    # Do not use this by itself
    # @WML: code to be added before moving the unit off the map

    {STORE_UNIT_VAR (id={ID}) image MUOM_tmp_image}
    [object]
        silent=yes

        [filter]
            id={ID}
        [/filter]

        [effect]
            apply_to=new_animation

            [extra_anim]
                flag=disappear
                start_time=0
                offset=0~2:400
                [frame]
                    image=$MUOM_tmp_image:400
                [/frame]
            [/extra_anim]
        [/effect]
    [/object]
    {CLEAR_VARIABLE MUOM_tmp_image}

    {WML}

    [modify_unit]
        [filter]
            id={ID}
        [/filter]

        facing={FACING}
    [/modify_unit]

    [animate_unit]
        [filter]
            id={ID}
        [/filter]

        flag=disappear
    [/animate_unit]

    [kill]
        id={ID}
    [/kill]
#enddef

#define MOVE_UNIT_OFF_MAP ID FACING
    # Animate a unit off the edge of the map.  The unit must be on the map.
    # This includes killing the unit at end, so it needs to be stored
    # before calling the macro if it is still needed later.
    # @ID: the id of the unit
    # @FACING: the direction in which to move the unit off the map

    {MOVE_UNIT_OFF_MAP_CORE {ID} {FACING} ()}
#enddef

#define MOVE_UNIT_TO_EDGE_AND_OFF_MAP ID X Y FACING
    # Same as MOVE_UNIT_OFF_MAP, but also moves it to the edge at coordinates
    # @x,@Y first, to make the transition smoother if it is desired to do it
    # in one motion, rather than stopping at the edge with a message or something.

    {MOVE_UNIT_OFF_MAP_CORE {ID} {FACING} (
        {MOVE_UNIT (id={ID}) {X} {Y}}
    )}
#enddef

#define PLACE_ROCK_WALKER FACING
    # Put a rock walker unit on the map
    # This is not a stand-alone macro, to be called from
    # PLACE_ROCK_WALKER_FROM_UNIT or PLACE_ROCK_NEW WALKER only

    {VARIABLE tmp_walker.facing {FACING}}

    [unit]
        id=rock_walker
        type=Invisible Unit
        facing={FACING}

        x,y=$tmp_walker.x,$tmp_walker.y
        side=$tmp_walker.side
        canrecruit=$tmp_walker.canrecruit
        max_hitpoints=$tmp_walker.max_hitpoints
        hitpoints=$tmp_walker.hitpoints
        max_experience=$tmp_walker.max_experience
        experience=$tmp_walker.experience

        [modifications]
            [object]
                [effect]
                    apply_to=new_animation
                    [extra_anim]
                        flag=emerge
                        start_time=0
                        alpha=0~0.3:600,0.3~1:400
                        offset=0~1:1000
                        [frame]
                            image=$tmp_walker.image:1000
                        [/frame]
                    [/extra_anim]
                [/effect]
            [/object]
        [/modifications]
    [/unit]
#enddef

#define PLACE_ROCK_WALKER_FROM_UNIT ID FACING
    # Replace an existing unit on the map with a Rock Walker of the same type
    # (usually this is done in a prestart event)
    # Needs to be done in combination with EMERGE_ROCK_WALKER
    # @ID: the id of the unit to be replaced by the rock walker
    # @FACING: facing direction - the animation will be shown in this direction

    [store_unit]
        [filter]
            id={ID}
        [/filter]

        kill=yes
        variable=tmp_walker
    [/store_unit]

    {PLACE_ROCK_WALKER {FACING}}
#enddef

#define PLACE_NEW_ROCK_WALKER FACING UNIT_WML
    # Put a new unit on the map as a Rock Walker
    # (this can be done outside prestart event, when the unit should not
    # become visible on the map first)
    # Needs to be done in combination with EMERGE_ROCK_WALKER
    # @ID: the id of the unit to be replaced by the rock walker
    # @FACING: facing direction - the animation will be shown in this direction

    [unit]
        {UNIT_WML}
        to_variable=tmp_walker
    [/unit]

    {PLACE_ROCK_WALKER {FACING}}
#enddef

#define EMERGE_ROCK_WALKER X Y
    # This needs to be done in combination with one of the PLACE_ROCK_* macros
    # @X,@Y: the hex where the rock walker emerges; could be calculated
    #  from @FACING of previous macro, but easier this way

    [animate_unit]
        [filter]
            id=rock_walker
        [/filter]
        flag=emerge
    [/animate_unit]

    [kill]
        id=rock_walker
    [/kill]

    [unstore_unit]
        variable=tmp_walker
        x,y={X},{Y}
    [/unstore_unit]

    {CLEAR_VARIABLE tmp_walker}
#enddef

#define LIGHT_BEAM X Y IPF SOUND_FILE WML
    # IPF: image path function
    {SCROLL_TO {X} {Y}}
    {SOUND {SOUND_FILE}}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-1.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-2.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-3.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-4.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-5.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-6.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-7.png{IPF} {X} {Y} 130}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-6.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-5.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-4.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-3.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-2.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM halo/holy/light-beam-1.png{IPF} {X} {Y} 30}
    {WML}
#enddef

#define PUFF X Y IPF SOUND_FILE
    # IPF: image path function
    {SCROLL_TO {X} {Y}}
    {SOUND {SOUND_FILE}}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-fail-1.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-fail-2.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-fail-3.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-fail-4.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-fail-5.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-fail-6.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-fail-7.png{IPF} {X} {Y} 60}
#enddef

#define QUICKBURST X Y IPF SOUND_FILE WML
    # Fireball and kill any unit on that hex
    # IPF: image path function
    {SCROLL_TO {X} {Y}}
    {SOUND {SOUND_FILE}}
    {PLACE_AND_REMOVE_ITEM projectiles/fire-breath-1.png{IPF} {X} {Y} 10}
    {PLACE_AND_REMOVE_ITEM projectiles/fire-breath-2.png{IPF} {X} {Y} 10}
    {PLACE_AND_REMOVE_ITEM projectiles/fire-breath-3.png{IPF} {X} {Y} 10}
    {PLACE_AND_REMOVE_ITEM projectiles/fire-breath-4.png{IPF} {X} {Y} 10}
    {WML}
    {PLACE_AND_REMOVE_ITEM projectiles/fire-breath-5.png{IPF} {X} {Y} 10}
    {PLACE_AND_REMOVE_ITEM projectiles/fire-breath-6.png{IPF} {X} {Y} 10}
    {PLACE_AND_REMOVE_ITEM projectiles/fire-breath-7.png{IPF} {X} {Y} 10}
#enddef

#define FIREBALL X Y IPF SOUND_FILE WML
    # Fireball and kill any unit on that hex
    # IPF: image path function
    {SCROLL_TO {X} {Y}}
    {SOUND {SOUND_FILE}}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-1.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-2.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-3.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-4.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-5.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-6.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-7.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-8.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-9.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-10.png{IPF} {X} {Y} 30}
    {WML}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-11.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-12.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-13.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-14.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-15.png{IPF} {X} {Y} 30}
    {PLACE_AND_REMOVE_ITEM projectiles/fireball-impact-16.png{IPF} {X} {Y} 30}
#enddef

#define FIREBALL_IN X Y IMAGE FACING
    # Play fading-in animation for a unit together with a black-and-white fireball
    # This places an invisible unit on the map and kills it again afterward,
    # so the hex must be empty for this to work
    # @x,@y: the location where
    # @IMAGE: the image to use for the animation
    # @FACING: the direction in which the unit should be facing

    [unit]
        id=FI_tmp_unit
        type=Invisible Unit

        x,y={X},{Y}
        facing={FACING}

        [modifications]
            [object]
                [effect]
                    apply_to=new_animation
                    [extra_anim]
                        flag=fireball_in
                        start_time=0
                        alpha=0~0.5:700,0.5~1:300
                        [frame]
                            image={IMAGE}:1000
                            halo=projectiles/fireball-impact-[1~16].png~GS():60
                            halo_y=-24
                            sound=fire.wav
                        [/frame]
                    [/extra_anim]
                [/effect]
            [/object]
        [/modifications]
    [/unit]

    [animate_unit]
        [filter]
            id=FI_tmp_unit
        [/filter]

        flag=fireball_in
    [/animate_unit]

    [kill]
        id=FI_tmp_unit
    [/kill]
#enddef

#define FIREBALL_OUT ID
    # Play fading-out animation for a unit together with a black-and-white fireball
    # The unit must be on the map.
    # This includes killing the unit at end, so it needs to be stored
    # before calling the macro if it is still needed later.
    # @ID: the id of the unit

    {STORE_UNIT_VAR (id={ID}) image FO_tmp_image}
    [object]
        silent=yes

        [filter]
            id={ID}
        [/filter]

        [effect]
            apply_to=new_animation

            [extra_anim]
                flag=fireball_out
                start_time=0
                alpha=1~0.5:300,0.5~0:500,0:200
                [frame]
                    image=$FO_tmp_image:1000
                    halo=projectiles/fireball-impact-[1~16].png~GS():60
                    halo_y=-24
                    sound=fire.wav
                [/frame]
            [/extra_anim]
        [/effect]
    [/object]
    {CLEAR_VARIABLE FO_tmp_image}

    [animate_unit]
        [filter]
            id={ID}
        [/filter]

        flag=fireball_out
    [/animate_unit]

    [kill]
        id={ID}
    [/kill]
#enddef

#define FIREBALL_UNDEAD_CORE ID IN_TIME IN_ALPHA OUT_TIME OUT_ALPHA
    # Core code for the FIREBALL_UNDEAD_IN and FIREBALL_UNDEAD_OUT macros
    # Do not call this directly
    [store_unit]
        [filter]
            id={ID}
        [/filter]

        variable=FU_tmp_unit
    [/store_unit]

    [set_variable]
        name=FU_skeleton1
        rand=skeleton/skeleton.png,archer.png,banebow.png,bone-shooter.png,deathblade.png,draug.png,revenant.png
    [/set_variable]
    [set_variable]
        name=FU_skeleton2
        rand=skeleton/skeleton.png,archer.png,banebow.png,bone-shooter.png,deathblade.png,draug.png,revenant.png
    [/set_variable]
    [set_variable]
        name=FU_master_sklaf1
        rand=undead-necromancers/ancient-lich.png,undead/ghast.png
    [/set_variable]
    [set_variable]
        name=FU_master_sklaf2
        rand=undead-necromancers/ancient-lich.png,undead/ghast.png
    [/set_variable]

    [object]
        silent=yes

        [filter]
            id={ID}
        [/filter]

        [effect]
            apply_to=new_animation

            [extra_anim]
                flag=fireball_undead
                start_time=0
                [frame]
                    image=$FU_tmp_unit.image:{IN_TIME}
                    halo=projectiles/fireball-impact-1.png~GS():{IN_TIME}
                    halo_y=-24
                    alpha={IN_ALPHA}
                    sound=fire.wav
                [/frame]
                [frame]
                    image=units/undead-skeletal/$FU_skeleton1:300
                    halo=projectiles/fireball-impact-[2~3].png~GS():150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:300
                    halo=projectiles/fireball-impact-[4~5].png~GS():150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=units/$FU_master_sklaf1:300
                    halo=projectiles/fireball-impact-[6~7].png~GS():150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:300
                    halo=projectiles/fireball-impact-[8~9].png~GS():150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=units/undead-skeletal/$FU_skeleton2:300
                    halo=projectiles/fireball-impact-[10~11].png~GS():150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:300
                    halo=projectiles/fireball-impact-[12~13].png~GS():150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=units/$FU_master_sklaf2:300
                    halo=projectiles/fireball-impact-[14~15].png~GS():150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:{OUT_TIME}
                    halo=projectiles/fireball-impact-[16].png~GS():{OUT_TIME}
                    halo_y=-24
                    alpha={OUT_ALPHA}
                [/frame]
            [/extra_anim]
        [/effect]
    [/object]

    [animate_unit]
        [filter]
            id={ID}
        [/filter]

        flag=fireball_undead
    [/animate_unit]

    [unstore_unit]
        variable=FU_tmp_unit
    [/unstore_unit]

    {CLEAR_VARIABLE FU_tmp_unit,FU_skeleton1,FU_skeleton2,FU_master_sklaf1,FU_master_sklaf2}
#enddef

#define FIREBALL_UNDEAD_IN SIDE UNIT_VARIABLE X Y FACING
    # Bring in a unit with fireball and going through a number of undead
    # unit types.
    # @SIDE: side on which the unit is supposed to be (can be different from that stored in the variable)
    # @UNIT_VARIABLE: name of the variable in which the unit is stored; the variable
    #   will not be cleared by the macro, can be used again later, if desired
    # @X,@Y: hex where to bring out the unit
    # @FACING: direction into which the unit is supposed to face

    {VARIABLE {UNIT_VARIABLE}.side {SIDE}}
    {VARIABLE {UNIT_VARIABLE}.facing {FACING}}
    [unstore_unit]
        variable={UNIT_VARIABLE}
        x,y={X},{Y}
    [/unstore_unit]

    {FIREBALL_UNDEAD_CORE ${UNIT_VARIABLE}.id 300 "0~1:150,1~0:150" 150 "0~1:150"}
#enddef

#define FIREBALL_UNDEAD_OUT ID
    # Fade out a unit while going through a number of undead unit types
    # @ID: the id of the unit; must be on the map
    {FIREBALL_UNDEAD_CORE {ID} 150 "1~0:150" 300 "0~1:150,1~0:150"}

    [kill]
        id={ID}
    [/kill]
#enddef

#define WHITE_MISSILE X Y IPF SOUND_FILE WML
    # Fireball and WML any unit on that hex
    # IPF: image path function
    {SCROLL_TO {X} {Y}}
    {SOUND {SOUND_FILE}}
    {PLACE_AND_REMOVE_ITEM projectiles/whitemissile-impact-1.png{IPF} {X} {Y} 20}
    {PLACE_AND_REMOVE_ITEM projectiles/whitemissile-impact-2.png{IPF} {X} {Y} 20}
    {PLACE_AND_REMOVE_ITEM projectiles/whitemissile-impact-3.png{IPF} {X} {Y} 20}
    {PLACE_AND_REMOVE_ITEM projectiles/whitemissile-impact-4.png{IPF} {X} {Y} 20}
    {PLACE_AND_REMOVE_ITEM projectiles/whitemissile-impact-5.png{IPF} {X} {Y} 20}
    {WML}
#enddef

#define LEADING_HALO X Y IPF SOUND_FILE
    # IPF: image path function
    {SCROLL_TO {X} {Y}}
    {SOUND {SOUND_FILE}}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-1.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-2.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-3.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-4.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-5.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-6.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-7.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/misc/leadership-flare-8.png{IPF} {X} {Y} 60}
#enddef

#define TELEPORT_ANIM_OUT2 X Y IPF
    {SCROLL_TO {X} {Y}}
    {PLACE_AND_REMOVE_ITEM halo/teleport-9.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-8.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-7.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-6.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-5.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-4.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-3.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-2.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-1.png{IPF} {X} {Y} 60}
#enddef

#define TELEPORT_ANIM_IN2 X Y IPF
    {SCROLL_TO {X} {Y}}
    {PLACE_AND_REMOVE_ITEM halo/teleport-1.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-2.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-3.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-4.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-5.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-6.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-7.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-8.png{IPF} {X} {Y} 60}
    {PLACE_AND_REMOVE_ITEM halo/teleport-9.png{IPF} {X} {Y} 60}
#enddef

#define TELEPORT_AWAY2 FILTER TO_X TO_Y NOT_TERRAIN IPF
    # Teleport a unit to given coordinates (or the closest available hex
    # That is NOT_TERRAIN
    # Called TELEPORT_AWAY2 because there's a somewhat different macro in Galuldur

    # Find the old location of the unit
    {STORE_UNIT_VAR {FILTER} x old_x}
    {STORE_UNIT_VAR {FILTER} y old_y}

    # Actions at the old location
    {SOUND entangle.wav}
    {TELEPORT_ANIM_OUT2 $old_x $old_y {IPF}}
    [store_unit]
        [filter]
            {FILTER}
        [/filter]
        variable=teleported_unit
        kill=yes
        animate=yes
    [/store_unit]
    {CLEAR_VARIABLE old_x,old_y}

    # Find the new location, DISTANCE away from X_ORG,Y_ORG
    {CLOSE_EMPTY_HEX {TO_X} {TO_Y} {NOT_TERRAIN} 0}

    # Unstore at the new location
    {SOUND entangle.wav}
    {TELEPORT_ANIM_IN2 $hex_x $hex_y {IPF}}
    [unstore_unit]
        variable=teleported_unit
        x,y=$hex_x,$hex_y
        animate=yes
    [/unstore_unit]

    # Capture village, in case unit ends up on one
    {CAPTURE_FILTERED_VILLAGES_COPY $teleported_unit.side x,y=$hex_x,$hex_y}

    # Redraw so that everything is shown as it is now
    {REDRAW 1}

    {CLEAR_VARIABLE teleported_unit,hex_x,hex_y}
#enddef

#define MOVE_UNIT_IMAGEMODS FILTER TO_X TO_Y IMAGE_MODS
    # Move a unit from (FROM_X,FROM_Y) to (TO_X,TO_Y) with IMAGE_MODS in place
    [store_unit]
        [filter]
            {FILTER}
        [/filter]
        variable=unit_to_be_moved
        kill=yes
    [/store_unit]
    [move_unit_fake]
        type=$unit_to_be_moved.type
        side=$unit_to_be_moved.side
        x=$unit_to_be_moved.x,{TO_X}
        y=$unit_to_be_moved.y,{TO_Y}
        image_mods={IMAGE_MODS}
    [/move_unit_fake]
    [unstore_unit]
        variable=unit_to_be_moved
        x,y={TO_X},{TO_Y}
        find_vacant=no
        check_passability=no
    [/unstore_unit]
    {CLEAR_VARIABLE unit_to_be_moved}
#enddef

#define HIGHLIGHT_IMAGE_SHORT X Y IMAGE BACKGROUND_VALUE
    # Same as the core macro, but one less blinking and different timing
    [scroll_to]
        x,y={X},{Y}
        check_fogged=false
    [/scroll_to]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
    {DELAY 500}
    [remove_item]
        x,y={X},{Y}
    [/remove_item]
    [item]
        x,y={X},{Y}
        image={BACKGROUND_VALUE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=200
    [/delay]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=500
    [/delay]
    [remove_item]
        x,y={X},{Y}
    [/remove_item]
    [item]
        x,y={X},{Y}
        image={BACKGROUND_VALUE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=200
    [/delay]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
#enddef

#define HIGHLIGHT_LABEL X Y LABEL
    # Scroll to and blink a label in and out a few times
    # X,Y: position of the label
    # LABEL: the label text
    {SCROLL_TO {X} {Y}}
    {DELAY 500}
    {REMOVE_LABEL {X} {Y}}
    {DELAY 200}
    {SET_LABEL {X} {Y} {LABEL}}
    {DELAY 500}
    {REMOVE_LABEL {X} {Y}}
    {DELAY 200}
    {SET_LABEL {X} {Y} {LABEL}}
    {DELAY 500}
#enddef

#define ATTACK_DEFENSE_ANIMATION FILTER1 FILTER2 TYPE HITS TEXT
    # Animation Unit 1 vs. Unit 2
    # FITLER1, FILTER2: filters for attacking and defending units
    # TYPE: melee or ranged
    # HITS: whether this is a hit or miss
    # TEXT: red floating text over defender

    #{DEBUG "Type: {TYPE}   Hits: {HITS}   Text: {TEXT}"}
    [animate_unit]
        flag=attack
        with_bars=yes
        [filter]
            {FILTER1}
        [/filter]
        [primary_attack]
            range={TYPE}
        [/primary_attack]
        [facing]
            [filter]
                {FILTER2}
            [/filter]
        [/facing]
        hits={HITS}
        [animate]
            flag=defend
            with_bars=yes
            [filter]
                {FILTER2}
            [/filter]
            [primary_attack]
                name={TYPE}
            [/primary_attack]
            [facing]
                [filter]
                    {FILTER1}
                [/filter]
            [/facing]
            text={TEXT}
            red,blue,green=255,0,0
            hits={HITS}
        [/animate]
    [/animate_unit]
#enddef

#define ATTACK_ATTACK_ANIMATION FILTER1 FILTER2 TYPE HITS1 TEXT1 HITS2 TEXT2
    # Animation Unit 1 vs. Unit 2, but both attacking at the same time
    # FITLER1, FILTER2: filters for attacking and defending units
    # TYPE: melee or ranged
    # HITS1, HITS2: whether this is a hit or miss
    # TEXT1, TEXT2: red floating text over defender

    [animate_unit]
        flag=attack
        with_bars=yes
        [filter]
            {FILTER1}
        [/filter]
        [primary_attack]
            range={TYPE}
        [/primary_attack]
        [facing]
            [filter]
                {FILTER2}
            [/filter]
        [/facing]
        text={TEXT1}
        red,blue,green=255,0,0
        hits={HITS1}
        [animate]
            flag=defend
            with_bars=yes
            [filter]
                {FILTER2}
            [/filter]
            [primary_attack]
                name={TYPE}
            [/primary_attack]
            [facing]
                [filter]
                    {FILTER1}
                [/filter]
            [/facing]
            text={TEXT2}
            red,blue,green=255,0,0
            hits={HITS2}
        [/animate]
    [/animate_unit]
#enddef

#define RECRUITING_ANIMATION FILTER1 FILTER2
    [animate_unit]
        flag=recruiting
        with_bars=yes
        [filter]
            {FILTER1}
        [/filter]
        [facing]
            [filter]
                {FILTER2}
            [/filter]
        [/facing]
        [animate]
            flag=recruited
            with_bars=yes
            [filter]
                {FILTER2}
            [/filter]
            [facing]
                [filter]
                    {FILTER1}
                [/filter]
            [/facing]
        [/animate]
    [/animate_unit]
#enddef

#define FIGHT_TO_DEATH UNIT1_ID UNIT2_ID FIRE_EVENT
    # Have two units fight until death
    # Just uses the standard damage for the first weapon type, nothing fancy
    # FIRE_EVENT: whether or not kill event should fire

    [store_unit]
        [filter]
            id={UNIT1_ID}
        [/filter]
        variable=FTD.unit1
    [/store_unit]
    [store_unit]
        [filter]
            id={UNIT2_ID}
        [/filter]
        variable=FTD.unit2
    [/store_unit]

    {VARIABLE FTD.damage1 $FTD.unit1.attack[0].damage}
    {VARIABLE FTD.damage2 $FTD.unit2.attack[0].damage}

    # Now fight until one of the units is dead
    [while]
        [have_unit]
            id=$FTD.unit1.id
        [/have_unit]
        [have_unit]
            id=$FTD.unit2.id
        [/have_unit]
        [do]
            # Figure out if it's a hit or miss -- I just do this 70/30, not by terrain
            [set_variable]
                name=FTD.random_chance
                rand=0..99
            [/set_variable]
            {IF_VAR FTD.random_chance less_than 70 (
                [then]
                    {VARIABLE FTD.hits yes}
                    {VARIABLE FTD.text $FTD.damage1}
                [/then]
                [else]
                    {VARIABLE FTD.hits no}
                    {VARIABLE FTD.text " "}
                [/else]
            )}

            # Animation Unit 1 vs. Unit 2 - always using melee attack
            {ATTACK_DEFENSE_ANIMATION id=$FTD.unit1.id id=$FTD.unit2.id melee $FTD.hits $FTD.text}

            # If it was a hit, reduce health (both in unit and stored variable
            {IF_VAR FTD.hits equals yes (
                [then]
                    {VARIABLE_OP FTD.unit2.hitpoints sub $FTD.damage1}
                    {MODIFY_UNIT id=$FTD.unit2.id hitpoints $FTD.unit2.hitpoints}
                [/then]
            )}

            # If hitpoints 0 or below, kill unit
            {IF_VAR FTD.unit2.hitpoints less_than 1 (
                [then]
                    [kill]
                        id=$FTD.unit2.id
                        animate=yes
                        fire_event={FIRE_EVENT}
                    [/kill]
                [/then]
                [else]  # otherwise, fight back
                    # Figure out if it's a hit or miss -- I just do this 70/30, not by terrain
                    [set_variable]
                        name=FTD.random_chance
                        rand=0..99
                    [/set_variable]
                    {IF_VAR FTD.random_chance less_than 70 (
                        [then]
                            {VARIABLE FTD.hits yes}
                            {VARIABLE FTD.text $FTD.damage2}
                        [/then]
                        [else]
                            {VARIABLE FTD.hits no}
                            {VARIABLE FTD.text " "}
                        [/else]
                    )}

                    # Animation Unit 1 vs. Unit 2 - always using melee attack
                    {ATTACK_DEFENSE_ANIMATION id=$FTD.unit2.id id=$FTD.unit1.id melee $FTD.hits $FTD.text}

                    # If it was a hit, reduce health (both in unit and stored variable
                    {IF_VAR FTD.hits equals yes (
                        [then]
                            {VARIABLE_OP FTD.unit1.hitpoints sub $FTD.damage2}
                            {MODIFY_UNIT id=$FTD.unit1.id hitpoints $FTD.unit1.hitpoints}
                        [/then]
                    )}

                    # If hitpoints 0 or below, kill unit
                    {IF_VAR FTD.unit1.hitpoints less_than 1 (
                        [then]
                            [kill]
                                id=$FTD.unit1.id
                                animate=yes
                                fire_event={FIRE_EVENT}
                            [/kill]
                        [/then]
                    )}
                [/else]
            )}
        [/do]
    [/while]

    {CLEAR_VARIABLE FTD}
#enddef

#define EARTHQUAKE_OWN ACTION_WML
    # Creates an earthquake-effect while performing ACTION_WML
    [sound]
        name=rumble.ogg
    [/sound]
    {SCROLL 0 5}
    {SCROLL 0 -5}
    {SCROLL 4 4}
    {SCROLL -4 -4}
    {SCROLL -4 4}
    {SCROLL 4 -4}
    {ACTION_WML}
    {SCROLL 3 6}
    {SCROLL 3 -4}
    {SCROLL -5 0}
    {SCROLL 2 -4}
#enddef
