#textdomain wesnoth-Grnk

# The EXTRA_ANIM_* macros are for playing new animations for units or on
# hexes using the [extra_anim] tags.  Empty hexes are dealt with by putting
# an invisible unit there.  Units for all macros are stored in the samw
# cariable: EA_unit

#define EXTRA_ANIM_UNIT_NO_STORE ID ANIM_WML
    # Play animation for a unit; it is assumed that the unit is already
    # stored in a variable when this macro is called.  Reasons might be to avoid
    # overhead if the unit is already stored, or because storing is unnecessary
    # because it will be killed at the end anyway.
    # @ID: id of the unit
    # @ANIM_WML: WML code to go into the [extra_anim] tag, excl. the flag

    [object]
        silent=yes

        [filter]
            id={ID}
        [/filter]

        [effect]
            apply_to=new_animation

            [extra_anim]
                flag=EAU_animation
                {ANIM_WML}
            [/extra_anim]
        [/effect]
    [/object]

    [animate_unit]
        [filter]
            id={ID}
        [/filter]

        flag=EAU_animation
    [/animate_unit]
#enddef

#define EXTRA_ANIM_UNIT ID ANIM_WML
    # Play animation for a unit.  Unlike EXTRA_ANIM_UNIT_NO_STORE, this stores
    # the unit into variable EA_unit first.
    # @ID: id of the unit
    # @ANIM_WML: WML code to go into the [extra_anim] tag, excl. the flag

    [store_unit]
        [filter]
            id={ID}
        [/filter]

        variable=EAU_unit
    [/store_unit]

    {EXTRA_ANIM_UNIT_NO_STORE {ID} {ANIM_WML}}

    [unstore_unit]
        variable=EAU_unit
    [/unstore_unit]

    {CLEAR_VARIABLE EAU_unit}
#enddef

#define EXTRA_ANIM_HEX X Y FACING ANIM_WML
    # Play an animation on a hex.  If a unit is already on the hex, macro
    # EXTRA_ANIM_UNIT_NO_STORE is used, otherwise an invisible unit
    # is temporarily placed there.
    # @x,@Y: coordinates of the hex
    # @FACING: facing of the unit; only relevant if the animation includes offsets
    # @ANIM_WML: WML code to go into the [extra_anim] tag, excl. the flag

    [store_unit]
        [filter]
            x,y={X},{Y}
        [/filter]

        variable=EAH_unit
    [/store_unit]

    [if]
        [variable]
            name=EAH_unit.length
            equals=0
        [/variable]

        [then]
			# If hex is empty, place an invisible unit there
			# Is set to be an enemy of all human controlled sides, or Side 1 if
			# no such side exists.  In the later case, the ally-orb will show
			# up briefly at the beginning of the animation

			[store_side]
				[enemy_of]
					controller=human
				[/enemy_of]

				variable=EAH_sides
			[/store_side]

			[if]
			    [variable]
			        name=EAH_sides.length
			        equals=0
			    [/variable]

			    [then]
			        {VARIABLE EAH_side 1}
			    [/then]

			    [else]
			        {VARIABLE EAH_side $EAH_sides[0].side}
			    [/else]
			[/if]

			[unit]
				id=EAH_unit_id
				type=Invisible Unit

				x,y={X},{Y}
				side=$EAH_side
				facing={FACING}

				[modifications]
					[object]
						[effect]
							apply_to=new_animation

							[extra_anim]
								flag=EAH_animation
								{ANIM_WML}
							[/extra_anim]
						[/effect]
					[/object]
				[/modifications]
			[/unit]

			# Now make the unit visible (so that the animation can be seen)
			# Cannot use [role] here (or at least I did not get it to work)
			[modify_unit]
				[filter]
					id=EAH_unit_id
				[/filter]

				role=IU_visible
			[/modify_unit]

			[animate_unit]
				[filter]
					id=EAH_unit_id
				[/filter]

				flag=EAH_animation
			[/animate_unit]

			[kill]
				id=EAH_unit_id
			[/kill]
		[/then]

		[else]
			{EXTRA_ANIM_UNIT_NO_STORE $EAH_unit.id {ANIM_WML}}

			[unstore_unit]
				variable=EAH_unit
			[/unstore_unit]

			{CLEAR_VARIABLE EAH_unit}
		[/else]
	[/if]
#enddef

#define WHITE_MISSILE ID IPF
    # White missile animation
    # @ID: the id of the unit
    # @IPF: the image path function to use for the projectile (not the unit)

    {EXTRA_ANIM_UNIT {ID} (
        [frame]
            halo=projectiles/whitemissile-impact-[1~6].png{IPF}:75
            sound=dragonstick.ogg
        [/frame]
    )}
#enddef

#define WHITE_MISSILE_KILL ID IPF
    # Play white missile animation on a unit plus unit kill at end

    {EXTRA_ANIM_UNIT_NO_STORE {ID} (
        [frame]
            halo=projectiles/whitemissile-impact-[1~6].png{IPF}:75
            sound=dragonstick.ogg
        [/frame]
    )}

    [kill]
        id={ID}
    [/kill]
#enddef

#define LEADING_HALO_PRUNES ID
    # Play leading Halo animation on a unit, always in prune colors

    {EXTRA_ANIM_UNIT {ID} (
        [frame]
			halo="halo/misc/leadership-flare-[1~8].png~CROP(0,20,72,52)~SCALE(0,120)~CS(0,-50,0):150"
			sound=entangle.wav
        [/frame]
    )}
#enddef

#define LEADING_HALO_PRUNES_HEX ID
    # Play leading Halo animation on a hex that might or might not have a unit
    # on it, always in prune colors

	{EXTRA_ANIM_HEX {X} {Y} se (
		[frame]
			halo="halo/misc/leadership-flare-[1~8].png~CROP(0,20,72,52)~SCALE(0,120)~CS(0,-50,0):150"
			sound=entangle.wav
		[/frame]
	)}
#enddef

#define PUFF_PRUNES ID
    # Play a puff animation on a unit, always in prune colors

    {EXTRA_ANIM_UNIT {ID} (
        [frame]
            halo="projectiles/fireball-fail-[1~7].png~GS()~CS(100,50,100):150"
            sound=torch-miss.ogg
        [/frame]
    )}
#enddef

#define LIGHT_BEAM ID
    # Play a light beam animation on a unit

    {EXTRA_ANIM_UNIT {ID} (
        [frame]
            halo="halo/holy/light-beam-[1~6].png:75,halo/holy/light-beam-7.png:200,halo/holy/light-beam-[6~1].png:75"
            sound=magic-holy-1.ogg
        [/frame]
    )}
#enddef

#define QUICKBURST_PRUNES ID
    # Play a quickburst animation on a unit, always in prune colors

    {EXTRA_ANIM_UNIT {ID} (
        [frame]
            halo="projectiles/fire-breath-[1~7].png~GS()~CS(50,0,50):50"
            sound=fire.wav
        [/frame]
    )}
#enddef

#define TELEPORT_ANIM_OUT ID IPF
    # Play a teleport-away animation on a unit

    {EXTRA_ANIM_UNIT {ID} (
        [frame]
            halo="halo/teleport-[9~1].png{IPF}:150"
            sound=entangle.wav
        [/frame]
    )}
#enddef

#define TELEPORT_ANIM_IN X Y IPF
    # Play a teleport-in animation on a hex

	{EXTRA_ANIM_HEX {X} {Y} se (
		[frame]
            halo="halo/teleport-[1~9].png{IPF}:150"
            sound=entangle.wav
		[/frame]
	)}
#enddef

#define FIREBALL_IN X Y IMAGE FACING IPF
    # Play fading-in animation for a unit together with a fireball
    # @X,@Y: the location where
    # @IMAGE: the image to use for the animation
    # @FACING: the direction in which the unit should be facing
    # @IPF: image path function

	{EXTRA_ANIM_HEX {X} {Y} {FACING} (
        alpha=0~0.5:700,0.5~1:300
        [frame]
            image={IMAGE}:1000
            halo=projectiles/fireball-impact-[1~16].png{IPF}:60
            halo_y=-24
            sound=fire.wav
        [/frame]
	)}
#enddef

#define FIREBALL_OUT_KILL ID IPF
    # Play fading-out animation for a unit together with a fireball
    # Kill the unit at the end
    # @ID: the id of the unit
    # @IPF: image path function

    {EXTRA_ANIM_UNIT {ID} (
        alpha=1~0.5:300,0.5~0:500,0:200
        [frame]
            image=$EAU_unit.image:1000
            halo=projectiles/fireball-impact-[1~16].png{IPF}:60
            halo_y=-24
            sound=fire.wav
        [/frame]
	)}

    [kill]
        id={ID}
    [/kill]
#enddef

#define FIREBALL_KILL ID
    # Kill a unit with a fireball and blackening animation
    # @ID: the id of the unit

    {EXTRA_ANIM_UNIT {ID} (
        blend_color=0,0,0
        blend_ratio=0~1:600,1:400
        alpha=1:600,1~-0.5:400
        [frame]
            image=$EAU_unit.image:1000
            halo=projectiles/fireball-impact-[1~16].png:60
            halo_y=-12
            sound=fire.wav
        [/frame]
	)}

    [kill]
        id={ID}
        fire_event=yes
    [/kill]
#enddef

#define FIREBALL X Y IPF
    # Fireball animation on a hex
    # IPF: image path function

	{EXTRA_ANIM_HEX {X} {Y} se (
        [frame]
            halo="projectiles/fireball-impact-[1~16].png{IPF}:60"
            halo_y=-12
            sound=fire.wav
        [/frame]
	)}
#enddef








#define MOVE_UNIT_ONTO_MAP SIDE TYPE X Y FACING UNIT_WML
    # Animate a unit onto the map from beyond the edge
    #
    # Unit parameters which always need to be given:
    #  @SIDE: side of unit; needs to be an enemy side for the player, otherwise
    #    the ellipse will blip in briefly.  This can be modified after the unit
    #    is placed on the map
    #  @TYPE: unit type
    #  @X, @Y: position where the unit appears, needs to be at the edge of the map
    #  @FACING: unit will appear on the map moving in this direction
    #
    # @UNIT_WML: other, optional keys that can be specified for the unit

    # Create the unit in an array
    [unit]
        side={SIDE}
        type={TYPE}
        x,y={X},{Y}
        facing={FACING}

        {UNIT_WML}

        to_variable=MUOM_new_unit
    [/unit]

    # Place an invisible unit with special 'appear' animation
    [unit]
        id=MUOM_tmp_unit
        type=Invisible Unit
        facing={FACING}

        x,y={X},{Y}
        side={SIDE}

        [modifications]
            [object]
                [effect]
                    apply_to=new_animation

                    [extra_anim]
                        flag=appear
                        offset=-2~0:400
                        [frame]
                            image=$MUOM_new_unit.image:400
                        [/frame]
                    [/extra_anim]
                [/effect]
            [/object]
        [/modifications]
    [/unit]

    # Now make the unit visible (so that the animation can be seen)
    # Cannot use [role] here (or at least I did not get it to work)
    [modify_unit]
        [filter]
            id=MUOM_tmp_unit
        [/filter]

        role=IU_visible
    [/modify_unit]

    # Play the animation
    [animate_unit]
        [filter]
            id=MUOM_tmp_unit
        [/filter]

        flag=appear
    [/animate_unit]

    # Overwrite the invisible unit with the real unit
    [unstore_unit]
        variable=MUOM_new_unit
        find_vacant=no
    [/unstore_unit]
#enddef

#define MOVE_UNIT_OFF_MAP_CORE ID FACING WML
    # Core macro for MOVE_UNIT_OFF_MAP and MOVE_UNIT_TO_EDGE_AND_OFF_MAP
    # Do not use this by itself
    # @WML: code to be added before moving the unit off the map

    {STORE_UNIT_VAR (id={ID}) image MUOM_tmp_image}
    [object]
        silent=yes

        [filter]
            id={ID}
        [/filter]

        [effect]
            apply_to=new_animation

            # Not sure why 800 here seems to work better than 400, but otherwise
            # the units disappear really quickly in the bear scenarios
            [extra_anim]
                flag=disappear
                offset=0~2:800
                [frame]
                    image=$MUOM_tmp_image:800
                [/frame]
            [/extra_anim]
        [/effect]
    [/object]
    {CLEAR_VARIABLE MUOM_tmp_image}

    {WML}

    [modify_unit]
        [filter]
            id={ID}
        [/filter]

        facing={FACING}
    [/modify_unit]

    [animate_unit]
        [filter]
            id={ID}
        [/filter]

        flag=disappear
    [/animate_unit]

    [kill]
        id={ID}
    [/kill]
#enddef

#define MOVE_UNIT_OFF_MAP ID FACING
    # Animate a unit off the edge of the map.  The unit must be on the map.
    # This includes killing the unit at end, so it needs to be stored
    # before calling the macro if it is still needed later.
    # @ID: the id of the unit
    # @FACING: the direction in which to move the unit off the map

    {MOVE_UNIT_OFF_MAP_CORE {ID} {FACING} ()}
#enddef

#define MOVE_UNIT_TO_EDGE_AND_OFF_MAP ID X Y FACING
    # Same as MOVE_UNIT_OFF_MAP, but also moves it to the edge at coordinates
    # @x,@Y first, to make the transition smoother if it is desired to do it
    # in one motion, rather than stopping at the edge with a message or something.

    {MOVE_UNIT_OFF_MAP_CORE {ID} {FACING} (
        {MOVE_UNIT (id={ID}) {X} {Y}}
    )}
#enddef

#define PLACE_ROCK_WALKER FACING
    # Put a rock walker unit on the map
    # This is not a stand-alone macro, to be called from
    # PLACE_ROCK_WALKER_FROM_UNIT or PLACE_ROCK_NEW WALKER only

    {VARIABLE tmp_walker.facing {FACING}}

    [unit]
        id=rock_walker
        type=Invisible Unit
        facing={FACING}

        x,y=$tmp_walker.x,$tmp_walker.y
        side=$tmp_walker.side
        canrecruit=$tmp_walker.canrecruit
        max_hitpoints=$tmp_walker.max_hitpoints
        hitpoints=$tmp_walker.hitpoints
        max_experience=$tmp_walker.max_experience
        experience=$tmp_walker.experience

        [modifications]
            [object]
                [effect]
                    apply_to=new_animation
                    [extra_anim]
                        flag=emerge
                        alpha=0~0.3:600,0.3~1:400
                        offset=0~1:1000
                        [frame]
                            image=$tmp_walker.image:1000
                        [/frame]
                    [/extra_anim]
                [/effect]
            [/object]
        [/modifications]
    [/unit]
#enddef

#define PLACE_ROCK_WALKER_FROM_UNIT ID FACING
    # Replace an existing unit on the map with a Rock Walker of the same type
    # (usually this is done in a prestart event)
    # Needs to be done in combination with EMERGE_ROCK_WALKER
    # @ID: the id of the unit to be replaced by the rock walker
    # @FACING: facing direction - the animation will be shown in this direction

    [store_unit]
        [filter]
            id={ID}
        [/filter]

        kill=yes
        variable=tmp_walker
    [/store_unit]

    {PLACE_ROCK_WALKER {FACING}}
#enddef

#define PLACE_ROCK_WALKER_FROM_VARIABLE VARIABLE X Y FACING
    # Take information from a unit variable and place a Rock Walker of the same
    # type and properties on the map.
    # (this can be done outside prestart event, when the unit should not
    # become visible on the map first)
    # Needs to be done in combination with EMERGE_ROCK_WALKER
    # @VARIABLE: name of the unit variable to be used
    # @X,@Y: hex where to place the rockwalker
    # @FACING: facing direction - the animation will be shown in this direction

    [unit]
        type=${VARIABLE}.type
        x={X}
        y={Y}
        side=${VARIABLE}.side
        canrecruit=${VARIABLE}.canrecruit
        max_hitpoints=${VARIABLE}.max_hitpoints
        hitpoints=${VARIABLE}.hitpoints
        max_experience=${VARIABLE}.max_experience
        experience=${VARIABLE}.experience
        image=${VARIABLE}.image

        to_variable=tmp_walker
    [/unit]

    {PLACE_ROCK_WALKER {FACING}}
#enddef

#define PLACE_NEW_ROCK_WALKER FACING UNIT_WML
    # Put a new unit on the map as a Rock Walker
    # (this can be done outside prestart event, when the unit should not
    # become visible on the map first)
    # Needs to be done in combination with EMERGE_ROCK_WALKER
    # @ID: the id of the unit to be replaced by the rock walker
    # @FACING: facing direction - the animation will be shown in this direction

    [unit]
        {UNIT_WML}
        to_variable=tmp_walker
    [/unit]

    {PLACE_ROCK_WALKER {FACING}}
#enddef

#define EMERGE_ROCK_WALKER X Y
    # This needs to be done in combination with one of the PLACE_ROCK_* macros
    # @X,@Y: the hex where the rock walker emerges; could be calculated
    #  from @FACING of previous macro, but easier this way

    # Now make the unit visible (so that the animation can be seen)
    # Cannot use [role] here (or at least I did not get it to work)
    [modify_unit]
        [filter]
            id=rock_walker
        [/filter]

        role=IU_visible
    [/modify_unit]

    [animate_unit]
        [filter]
            id=rock_walker
        [/filter]
        flag=emerge
    [/animate_unit]

    [kill]
        id=rock_walker
    [/kill]

    [unstore_unit]
        variable=tmp_walker
        x,y={X},{Y}
    [/unstore_unit]

    {CLEAR_VARIABLE tmp_walker}
#enddef



#define FIREBALL_UNDEAD_CORE ID IN_TIME IN_ALPHA OUT_TIME OUT_ALPHA
    # Core code for the FIREBALL_UNDEAD_IN and FIREBALL_UNDEAD_OUT macros
    # Do not call this directly
    [store_unit]
        [filter]
            id={ID}
        [/filter]

        variable=FU_tmp_unit
    [/store_unit]

    [set_variable]
        name=FU_skeleton1
        rand=skeleton/skeleton.png,archer.png,banebow.png,bone-shooter.png,deathblade.png,draug.png,revenant.png
    [/set_variable]
    [set_variable]
        name=FU_skeleton2
        rand=skeleton/skeleton.png,archer.png,banebow.png,bone-shooter.png,deathblade.png,draug.png,revenant.png
    [/set_variable]
    [set_variable]
        name=FU_master_sklaf1
        rand=undead-necromancers/ancient-lich.png,undead/ghast.png
    [/set_variable]
    [set_variable]
        name=FU_master_sklaf2
        rand=undead-necromancers/ancient-lich.png,undead/ghast.png
    [/set_variable]

    [object]
        silent=yes

        [filter]
            id={ID}
        [/filter]

        [effect]
            apply_to=new_animation

            [extra_anim]
                flag=fireball_undead
                [frame]
                    image=$FU_tmp_unit.image:{IN_TIME}
                    halo=projectiles/fireball-impact-1.png~GS()~CS(0,-50,0):{IN_TIME}
                    halo_y=-24
                    alpha={IN_ALPHA}
                    sound=fire.wav
                [/frame]
                [frame]
                    image=units/undead-skeletal/$FU_skeleton1:300
                    halo=projectiles/fireball-impact-[2~3].png~GS()~CS(0,-50,0):150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:300
                    halo=projectiles/fireball-impact-[4~5].png~GS()~CS(0,-50,0):150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=units/$FU_master_sklaf1:300
                    halo=projectiles/fireball-impact-[6~7].png~GS()~CS(0,-50,0):150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:300
                    halo=projectiles/fireball-impact-[8~9].png~GS()~CS(0,-50,0):150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=units/undead-skeletal/$FU_skeleton2:300
                    halo=projectiles/fireball-impact-[10~11].png~GS()~CS(0,-50,0):150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:300
                    halo=projectiles/fireball-impact-[12~13].png~GS()~CS(0,-50,0):150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=units/$FU_master_sklaf2:300
                    halo=projectiles/fireball-impact-[14~15].png~GS()~CS(0,-50,0):150
                    halo_y=-24
                    alpha=0~1:150,1~0:150
                [/frame]
                [frame]
                    image=$FU_tmp_unit.image:{OUT_TIME}
                    halo=projectiles/fireball-impact-[16].png~GS()~CS(0,-50,0):{OUT_TIME}
                    halo_y=-24
                    alpha={OUT_ALPHA}
                [/frame]
            [/extra_anim]
        [/effect]
    [/object]

    [animate_unit]
        [filter]
            id={ID}
        [/filter]

        flag=fireball_undead
    [/animate_unit]

    [unstore_unit]
        variable=FU_tmp_unit
    [/unstore_unit]

    {CLEAR_VARIABLE FU_tmp_unit,FU_skeleton1,FU_skeleton2,FU_master_sklaf1,FU_master_sklaf2}
#enddef

#define FIREBALL_UNDEAD_IN SIDE UNIT_VARIABLE X Y FACING
    # Bring in a unit with fireball and going through a number of undead
    # unit types.
    # @SIDE: side on which the unit is supposed to be (can be different from that stored in the variable)
    # @UNIT_VARIABLE: name of the variable in which the unit is stored; the variable
    #   will not be cleared by the macro, can be used again later, if desired
    # @X,@Y: hex where to bring out the unit
    # @FACING: direction into which the unit is supposed to face

    {VARIABLE {UNIT_VARIABLE}.side {SIDE}}
    {VARIABLE {UNIT_VARIABLE}.facing {FACING}}
    [unstore_unit]
        variable={UNIT_VARIABLE}
        x,y={X},{Y}
    [/unstore_unit]

    {FIREBALL_UNDEAD_CORE ${UNIT_VARIABLE}.id 300 "0~1:150,1~0:150" 150 "0~1:150"}
#enddef

#define FIREBALL_UNDEAD_OUT ID
    # Fade out a unit while going through a number of undead unit types
    # @ID: the id of the unit; must be on the map
    {FIREBALL_UNDEAD_CORE {ID} 150 "1~0:150" 300 "0~1:150,1~0:150"}

    [kill]
        id={ID}
    [/kill]
#enddef



#define TELEPORT_AWAY FILTER TO_X TO_Y NOT_TERRAIN IPF
    # Teleport a unit to given coordinates (or the closest available hex
    # That is NOT_TERRAIN

    # Find the old location of the unit
    {STORE_UNIT_VAR {FILTER} id TA_unit_id}

    # Actions at the old location
    {TELEPORT_ANIM_OUT $TA_unit_id {IPF}}
    [store_unit]
        [filter]
            {FILTER}
        [/filter]
        variable=teleported_unit
        kill=yes
        animate=yes
    [/store_unit]
    {CLEAR_VARIABLE TA_unit_id}

    # Find the new location, DISTANCE away from X_ORG,Y_ORG
    {CLOSE_EMPTY_HEX {TO_X} {TO_Y} {NOT_TERRAIN} 0}

    # Unstore at the new location
    {TELEPORT_ANIM_IN $hex_x $hex_y {IPF}}
    [unstore_unit]
        variable=teleported_unit
        x,y=$hex_x,$hex_y
        animate=yes
    [/unstore_unit]

    # Capture village, in case unit ends up on one
    {CAPTURE_FILTERED_VILLAGES_COPY $teleported_unit.side x,y=$hex_x,$hex_y}

    # Redraw so that everything is shown as it is now
    {REDRAW 1}

    {CLEAR_VARIABLE teleported_unit,hex_x,hex_y}
#enddef

#define MOVE_UNIT_IMAGEMODS FILTER TO_X TO_Y IMAGE_MODS
    # Move a unit from (FROM_X,FROM_Y) to (TO_X,TO_Y) with IMAGE_MODS in place
    [store_unit]
        [filter]
            {FILTER}
        [/filter]
        variable=unit_to_be_moved
        kill=yes
    [/store_unit]
    [move_unit_fake]
        type=$unit_to_be_moved.type
        side=$unit_to_be_moved.side
        x=$unit_to_be_moved.x,{TO_X}
        y=$unit_to_be_moved.y,{TO_Y}
        image_mods={IMAGE_MODS}
    [/move_unit_fake]
    [unstore_unit]
        variable=unit_to_be_moved
        x,y={TO_X},{TO_Y}
        find_vacant=no
        check_passability=no
    [/unstore_unit]
    {CLEAR_VARIABLE unit_to_be_moved}
#enddef

#define HIGHLIGHT_IMAGE_SHORT X Y IMAGE BACKGROUND_VALUE
    # Same as the core macro, but one less blinking and different timing
    [scroll_to]
        x,y={X},{Y}
        check_fogged=false
    [/scroll_to]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
    {DELAY 500}
    [remove_item]
        x,y={X},{Y}
    [/remove_item]
    [item]
        x,y={X},{Y}
        image={BACKGROUND_VALUE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=200
    [/delay]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=500
    [/delay]
    [remove_item]
        x,y={X},{Y}
    [/remove_item]
    [item]
        x,y={X},{Y}
        image={BACKGROUND_VALUE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=200
    [/delay]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
#enddef

#define HIGHLIGHT_LABEL X Y LABEL
    # Scroll to and blink a label in and out a few times
    # X,Y: position of the label
    # LABEL: the label text
    {SCROLL_TO {X} {Y}}
    {DELAY 500}
    {REMOVE_LABEL {X} {Y}}
    {DELAY 200}
    {SET_LABEL {X} {Y} {LABEL}}
    {DELAY 500}
    {REMOVE_LABEL {X} {Y}}
    {DELAY 200}
    {SET_LABEL {X} {Y} {LABEL}}
    {DELAY 500}
#enddef

#define ATTACK_DEFENSE_ANIMATION FILTER1 FILTER2 TYPE HITS TEXT
    # Animation Unit 1 vs. Unit 2
    # FITLER1, FILTER2: filters for attacking and defending units
    # TYPE: melee or ranged
    # HITS: whether this is a hit or miss
    # TEXT: red floating text over defender

    #{DEBUG "Type: {TYPE}   Hits: {HITS}   Text: {TEXT}"}
    [animate_unit]
        flag=attack
        with_bars=yes
        [filter]
            {FILTER1}
        [/filter]
        [primary_attack]
            range={TYPE}
        [/primary_attack]
        [facing]
            [filter]
                {FILTER2}
            [/filter]
        [/facing]
        hits={HITS}
        [animate]
            flag=defend
            with_bars=yes
            [filter]
                {FILTER2}
            [/filter]
            [primary_attack]
                name={TYPE}
            [/primary_attack]
            [facing]
                [filter]
                    {FILTER1}
                [/filter]
            [/facing]
            text={TEXT}
            red,blue,green=255,0,0
            hits={HITS}
        [/animate]
    [/animate_unit]
#enddef

#define ATTACK_ATTACK_ANIMATION FILTER1 FILTER2 TYPE HITS1 TEXT1 HITS2 TEXT2
    # Animation Unit 1 vs. Unit 2, but both attacking at the same time
    # FITLER1, FILTER2: filters for attacking and defending units
    # TYPE: melee or ranged
    # HITS1, HITS2: whether this is a hit or miss
    # TEXT1, TEXT2: red floating text over defender

    [animate_unit]
        flag=attack
        with_bars=yes
        [filter]
            {FILTER1}
        [/filter]
        [primary_attack]
            range={TYPE}
        [/primary_attack]
        [facing]
            [filter]
                {FILTER2}
            [/filter]
        [/facing]
        text={TEXT1}
        red,blue,green=255,0,0
        hits={HITS1}
        [animate]
            flag=defend
            with_bars=yes
            [filter]
                {FILTER2}
            [/filter]
            [primary_attack]
                name={TYPE}
            [/primary_attack]
            [facing]
                [filter]
                    {FILTER1}
                [/filter]
            [/facing]
            text={TEXT2}
            red,blue,green=255,0,0
            hits={HITS2}
        [/animate]
    [/animate_unit]
#enddef

#define RECRUITING_ANIMATION FILTER1 FILTER2
    [animate_unit]
        flag=recruiting
        with_bars=yes
        [filter]
            {FILTER1}
        [/filter]
        [facing]
            [filter]
                {FILTER2}
            [/filter]
        [/facing]
        [animate]
            flag=recruited
            with_bars=yes
            [filter]
                {FILTER2}
            [/filter]
            [facing]
                [filter]
                    {FILTER1}
                [/filter]
            [/facing]
        [/animate]
    [/animate_unit]
#enddef

#define FIGHT_TO_DEATH UNIT1_ID UNIT2_ID FIRE_EVENT
    # Have two units fight until death
    # Just uses the standard damage for the first weapon type, nothing fancy
    # FIRE_EVENT: whether or not kill event should fire

    [store_unit]
        [filter]
            id={UNIT1_ID}
        [/filter]
        variable=FTD.unit1
    [/store_unit]
    [store_unit]
        [filter]
            id={UNIT2_ID}
        [/filter]
        variable=FTD.unit2
    [/store_unit]

    {VARIABLE FTD.damage1 $FTD.unit1.attack[0].damage}
    {VARIABLE FTD.damage2 $FTD.unit2.attack[0].damage}

    # Now fight until one of the units is dead
    [while]
        [have_unit]
            id=$FTD.unit1.id
        [/have_unit]
        [have_unit]
            id=$FTD.unit2.id
        [/have_unit]
        [do]
            # Figure out if it's a hit or miss -- I just do this 70/30, not by terrain
            [set_variable]
                name=FTD.random_chance
                rand=0..99
            [/set_variable]
            {IF_VAR FTD.random_chance less_than 70 (
                [then]
                    {VARIABLE FTD.hits yes}
                    {VARIABLE FTD.text $FTD.damage1}
                [/then]
                [else]
                    {VARIABLE FTD.hits no}
                    {VARIABLE FTD.text " "}
                [/else]
            )}

            # Animation Unit 1 vs. Unit 2 - always using melee attack
            {ATTACK_DEFENSE_ANIMATION id=$FTD.unit1.id id=$FTD.unit2.id melee $FTD.hits $FTD.text}

            # If it was a hit, reduce health (both in unit and stored variable
            {IF_VAR FTD.hits equals yes (
                [then]
                    {VARIABLE_OP FTD.unit2.hitpoints sub $FTD.damage1}
                    {MODIFY_UNIT id=$FTD.unit2.id hitpoints $FTD.unit2.hitpoints}
                [/then]
            )}

            # If hitpoints 0 or below, kill unit
            {IF_VAR FTD.unit2.hitpoints less_than 1 (
                [then]
                    [kill]
                        id=$FTD.unit2.id
                        animate=yes
                        fire_event={FIRE_EVENT}
                    [/kill]
                [/then]
                [else]  # otherwise, fight back
                    # Figure out if it's a hit or miss -- I just do this 70/30, not by terrain
                    [set_variable]
                        name=FTD.random_chance
                        rand=0..99
                    [/set_variable]
                    {IF_VAR FTD.random_chance less_than 70 (
                        [then]
                            {VARIABLE FTD.hits yes}
                            {VARIABLE FTD.text $FTD.damage2}
                        [/then]
                        [else]
                            {VARIABLE FTD.hits no}
                            {VARIABLE FTD.text " "}
                        [/else]
                    )}

                    # Animation Unit 1 vs. Unit 2 - always using melee attack
                    {ATTACK_DEFENSE_ANIMATION id=$FTD.unit2.id id=$FTD.unit1.id melee $FTD.hits $FTD.text}

                    # If it was a hit, reduce health (both in unit and stored variable
                    {IF_VAR FTD.hits equals yes (
                        [then]
                            {VARIABLE_OP FTD.unit1.hitpoints sub $FTD.damage2}
                            {MODIFY_UNIT id=$FTD.unit1.id hitpoints $FTD.unit1.hitpoints}
                        [/then]
                    )}

                    # If hitpoints 0 or below, kill unit
                    {IF_VAR FTD.unit1.hitpoints less_than 1 (
                        [then]
                            [kill]
                                id=$FTD.unit1.id
                                animate=yes
                                fire_event={FIRE_EVENT}
                            [/kill]
                        [/then]
                    )}
                [/else]
            )}
        [/do]
    [/while]

    {CLEAR_VARIABLE FTD}
#enddef

#define EARTHQUAKE_OWN ACTION_WML
    # Creates an earthquake-effect while performing ACTION_WML
    [sound]
        name=rumble.ogg
    [/sound]
    {SCROLL 0 5}
    {SCROLL 0 -5}
    {SCROLL 4 4}
    {SCROLL -4 -4}
    {SCROLL -4 4}
    {SCROLL 4 -4}
    {ACTION_WML}
    {SCROLL 3 6}
    {SCROLL 3 -4}
    {SCROLL -5 0}
    {SCROLL 2 -4}
#enddef

#define ANIMATED_PORTAL_IMAGE1 OP SCL X Y
    # Used by ANIMATED_PORTAL macro; don't use by itself

    ../misc/blank-hex.png~BLIT(../scenery/whirlpool.png~GS()~CS(0,-50,0)~O({OP})~SCALE({SCL},{SCL}),{X},{Y}):100
#enddef

#define ANIMATED_PORTAL_IMAGE2 OP SCL X Y
    # Used by ANIMATED_PORTAL macro; don't use by itself

    ../misc/blank-hex.png~BLIT(../scenery/whirlpool.png~FL()~GS()~CS(0,-50,0)~O({OP})~SCALE({SCL},{SCL}),{X},{Y}):100
#enddef

#define ANIMATED_PORTAL_IMAGE3 OP SCL X Y
    # Used by ANIMATED_PORTAL macro; don't use by itself

    ../misc/blank-hex.png~BLIT(../scenery/whirlpool.png~FL('vert')~GS()~CS(0,-50,0)~O({OP})~SCALE({SCL},{SCL}),{X},{Y}):100
#enddef

#define ANIMATED_PORTAL_IMAGE4 OP SCL X Y
    # Used by ANIMATED_PORTAL macro; don't use by itself

    ../misc/blank-hex.png~BLIT(../scenery/whirlpool.png~FL('vert','horiz')~GS()~CS(0,-50,0)~O({OP})~SCALE({SCL},{SCL}),{X},{Y}):100
#enddef

#define ANIMATED_PORTAL_NAME
    # Used by SET_PORTAL_ANIM macro; don't use by itself

    {ANIMATED_PORTAL_IMAGE1 0.50 72  0  0},
    {ANIMATED_PORTAL_IMAGE2 0.48 72  0  0},
    {ANIMATED_PORTAL_IMAGE3 0.46 68  2  4},
    {ANIMATED_PORTAL_IMAGE4 0.44 64  4  8},
    {ANIMATED_PORTAL_IMAGE1 0.42 60  6 12},
    {ANIMATED_PORTAL_IMAGE2 0.40 56  8 16},
    {ANIMATED_PORTAL_IMAGE3 0.38 52 10 20},
    {ANIMATED_PORTAL_IMAGE4 0.36 48 12 24},
    {ANIMATED_PORTAL_IMAGE1 0.34 44 14 28},
    {ANIMATED_PORTAL_IMAGE2 0.32 40 16 32},
    {ANIMATED_PORTAL_IMAGE3 0.30 36 18 36},
    {ANIMATED_PORTAL_IMAGE4 0.28 32 20 40},
    {ANIMATED_PORTAL_IMAGE1 0.26 28 22 44},
    {ANIMATED_PORTAL_IMAGE2 0.24 24 24 48},
    {ANIMATED_PORTAL_IMAGE3 0.22 20 26 52},
    {ANIMATED_PORTAL_IMAGE4 0.20 16 28 56},
    {ANIMATED_PORTAL_IMAGE1 0.20 12 30 60},
    {ANIMATED_PORTAL_IMAGE2 0.20 12 30 60},
    {ANIMATED_PORTAL_IMAGE3 0.20 12 30 60},
    {ANIMATED_PORTAL_IMAGE4 0.20 12 30 60},
    {ANIMATED_PORTAL_IMAGE1 0.20 16 28 56},
    {ANIMATED_PORTAL_IMAGE2 0.22 20 26 52},
    {ANIMATED_PORTAL_IMAGE3 0.24 24 24 48},
    {ANIMATED_PORTAL_IMAGE4 0.26 28 22 44},
    {ANIMATED_PORTAL_IMAGE1 0.28 32 20 40},
    {ANIMATED_PORTAL_IMAGE2 0.30 36 18 36},
    {ANIMATED_PORTAL_IMAGE3 0.32 40 16 32},
    {ANIMATED_PORTAL_IMAGE4 0.34 44 14 28},
    {ANIMATED_PORTAL_IMAGE1 0.36 48 12 24},
    {ANIMATED_PORTAL_IMAGE2 0.38 52 10 20},
    {ANIMATED_PORTAL_IMAGE3 0.40 56  8 16},
    {ANIMATED_PORTAL_IMAGE4 0.42 60  6 12},
    {ANIMATED_PORTAL_IMAGE1 0.44 64  4  8},
    {ANIMATED_PORTAL_IMAGE2 0.46 68  2  4}
#enddef

#define SET_PORTAL_ANIM X Y
    # Place an animated whirlpool with chasm below it at @x,@y
    # This needs to be placed at scenario toplevel

    [terrain_graphics]
        x={X}
        y={Y}
        [tile]
            x=0
            y=0
            type=Qxe
            [image]
                layer=0
                name="{ANIMATED_PORTAL_NAME}"
            [/image]
        [/tile]
    [/terrain_graphics]
#enddef

#define OPEN_PORTAL X Y
    [terrain]
        x={X}
        y={Y}
        terrain=Qxe
    [/terrain]
    [redraw]
    [/redraw]
#enddef

#define PORTAL_FRAME IMAGE OP SCL X Y N
    # Used by PORTAL_IN macro; don't use by itself

    [frame]
        image={IMAGE}~O({OP})~SCALE({SCL},{SCL}):100
        #halo=projectiles/fireball-impact-{N}.png~GS()~CS(0,-50,0)~O({OP}):60
        x,y={X},{Y}
        halo_y=-24
        sound=magic-dark-big.ogg
    [/frame]
#enddef

#define PORTAL_IN X Y IMAGE FACING
    # Play fading-in animation for a unit coming through a portal
    # This places an invisible unit on the map and kills it again afterward,
    # so the hex must be empty for this to work
    # @x,@y: the location of the portal hex
    # @IMAGE: the image to use for the animation
    # @FACING: the direction in which the unit should be facing

    [unit]
        id=PI_tmp_unit
        type=Invisible Unit

        x,y={X},{Y}
        facing={FACING}

        [modifications]
            [object]
                [effect]
                    apply_to=new_animation
                    [extra_anim]
                        flag=portal_in

                        {PORTAL_FRAME {IMAGE} 0.30  7  0 39  1}
                        {PORTAL_FRAME {IMAGE} 0.30 12  0 36  2}
                        {PORTAL_FRAME {IMAGE} 0.30 17  0 33  3}
                        {PORTAL_FRAME {IMAGE} 0.32 22  0 30  4}
                        {PORTAL_FRAME {IMAGE} 0.34 27  0 27  5}
                        {PORTAL_FRAME {IMAGE} 0.36 32  0 24  6}
                        {PORTAL_FRAME {IMAGE} 0.38 37  0 21  7}
                        {PORTAL_FRAME {IMAGE} 0.40 42  0 18  8}
                        {PORTAL_FRAME {IMAGE} 0.42 47  0 15  9}
                        {PORTAL_FRAME {IMAGE} 0.44 52  0 12 10}
                        {PORTAL_FRAME {IMAGE} 0.46 57  0  9 11}
                        {PORTAL_FRAME {IMAGE} 0.48 63  0  6 12}
                        {PORTAL_FRAME {IMAGE} 0.50 67  0  3 13}
                        {PORTAL_FRAME {IMAGE} 0.60 72  0 -0 14}
                        {PORTAL_FRAME {IMAGE} 0.70 72  0 -2 15}
                        {PORTAL_FRAME {IMAGE} 0.80 72  0  0 16}
                    [/extra_anim]
                [/effect]
            [/object]
        [/modifications]
    [/unit]

    [animate_unit]
        [filter]
            id=PI_tmp_unit
        [/filter]

        flag=portal_in
    [/animate_unit]

    [kill]
        id=PI_tmp_unit
    [/kill]
#enddef

#define PORTAL_FALL X Y
    # Play fading-out animation for a unit falling down a portal hex
    # and kill the unit.
    # @x,@y: the location of the portal hex

    [store_unit]
        [filter]
            x,y={X},{Y}
        [/filter]

        variable=PF_tmp_unit
    [/store_unit]

    {MESSAGE $PF_tmp_unit.id "" "" _"$PF_tmp_unit.name fall!"}

    [object]
        silent=yes

        [filter]
            x,y={X},{Y}
        [/filter]

        [effect]
            apply_to=new_animation
            [extra_anim]
                flag=fall

                {PORTAL_FRAME $PF_tmp_unit.image 0.80 72  0  0 16}
                {PORTAL_FRAME $PF_tmp_unit.image 0.70 72  0 -2 15}
                {PORTAL_FRAME $PF_tmp_unit.image 0.60 72  0 -0 14}
                {PORTAL_FRAME $PF_tmp_unit.image 0.50 67  0  3 13}
                {PORTAL_FRAME $PF_tmp_unit.image 0.48 63  0  6 12}
                {PORTAL_FRAME $PF_tmp_unit.image 0.46 57  0  9 11}
                {PORTAL_FRAME $PF_tmp_unit.image 0.44 52  0 12 10}
                {PORTAL_FRAME $PF_tmp_unit.image 0.42 47  0 15  9}
                {PORTAL_FRAME $PF_tmp_unit.image 0.40 42  0 18  8}
                {PORTAL_FRAME $PF_tmp_unit.image 0.38 37  0 21  7}
                {PORTAL_FRAME $PF_tmp_unit.image 0.36 32  0 24  6}
                {PORTAL_FRAME $PF_tmp_unit.image 0.34 27  0 27  5}
                {PORTAL_FRAME $PF_tmp_unit.image 0.32 22  0 30  4}
                {PORTAL_FRAME $PF_tmp_unit.image 0.30 17  0 33  3}
                {PORTAL_FRAME $PF_tmp_unit.image 0.30 12  0 36  2}
                {PORTAL_FRAME $PF_tmp_unit.image 0.30  7  0 39  1}
            [/extra_anim]
        [/effect]
    [/object]
    {CLEAR_VARIABLE PF_tmp_unit}

    [animate_unit]
        [filter]
            x,y={X},{Y}
        [/filter]

        flag=fall
    [/animate_unit]

    [kill]
        x,y={X},{Y}
    [/kill]
#enddef
