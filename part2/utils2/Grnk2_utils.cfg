#textdomain wesnoth-Grnk

#define MASTERS_LAIR SIDE VIEWING_SIDE
    [modify_side]
        side={VIEWING_SIDE}
        shroud=yes
    [/modify_side]

    [redraw]
    [/redraw]

    [kill]
        x=1-999 # keep the ones on the recall list
    [/kill]

    [replace_map]
        map="{~add-ons/Grnk/part2/maps/Masters_Lair.map}"
        shrink=yes
        expand=yes
    [/replace_map]

    {UNIT {SIDE} (Ancient Lich) 25 4 (id,name,canrecruit=Master,_"The Master",yes)}
    {UNIT {SIDE} (Necrophage) 26 5 (id,name=Sklaf,Sklaf)}

    {UNIT {SIDE} (Deathblade) 16 7 ()}
    {UNIT {SIDE} (Bone Shooter) 16 9 ()}
    {UNIT {SIDE} (Draug) 26 7 ()}
    {UNIT {SIDE} (Banebow) 32 4 ()}
    {UNIT {SIDE} (Draug) 30 16 ()}

    [modify_side]
        side={VIEWING_SIDE}
        shroud=no
    [/modify_side]

    [redraw]
    [/redraw]

    {SCROLL_TO 22 6}
#enddef

#define UNDEAD_THRU_PORTAL X Y SIDE FACING TO_X TO_Y BRITTLIZE
    # @BRITTLIZE: set to 'yes' if units is to be made brittle

    {RANDOM "1..4"}

    [switch]
        variable=random

        [case]
            value=1

            {VARIABLE UTP_type Revenant}
#ifver WESNOTH_VERSION < 1.13.0
            {VARIABLE UTP_image "units/undead-skeletal/revenant.png"}
#else
            {VARIABLE UTP_image "units/undead-skeletal/revenant/revenant.png"}
#endif
        [/case]

        [case]
            value=2

            {VARIABLE UTP_type "Bone Shooter"}
            {VARIABLE UTP_image "units/undead-skeletal/bone-shooter.png"}
        [/case]

        [case]
            value=3

            {VARIABLE UTP_type Draug}
            {VARIABLE UTP_image "units/undead-skeletal/draug.png"}
        [/case]

        [case]
            value=4

            {VARIABLE UTP_type Banebow}
            {VARIABLE UTP_image "units/undead-skeletal/banebow.png"}
        [/case]
    [/switch]

    {PORTAL_IN {X} {Y} "$UTP_image" {FACING}}

    {UNIT {SIDE} "$UTP_type" {X} {Y} (facing={FACING})}

    {VARIABLE UTP_brittle {BRITTLIZE}}
    [if]
        [variable]
            name=UTP_brittle
            equals=yes
        [/variable]

        [then]
            {BRITTLE (x,y={X},{Y})}
        [/then]
    [/if]

    {CLEAR_VARIABLE random,UTP_type,UTP_image,UTP_brittle}

    {MOVE_UNIT (x,y={X},{Y}) {TO_X} {TO_Y}}
#enddef

#define BEAR_SIDE SIDE YRANGE_RANDOM XRANGE_COORD YRANGE_COORD
    # Set up the AI side for the bear in S8 and S9
    # This is specialized for those scenarios, won't work in general
    # Bear always moves in on the left (x=1) for the y ranges given
    # in the macro arguments.
    #
    # @YRANGE_RANDOM: range of y coordinates for bear to appear in RANDOM macro format
    # @X/YRANGE_COORDS: range of x/y coordinates for bear to leave in x,y= key format
    #
    # Example: {BEAR_SIDE 3 "1..7,13..16,20..27" "2-5,2-5,2-5" "1-7,13-16,20-27"}

    [side]
        side={SIDE}
        controller=ai
        no_leader=yes
        hidden=yes

        team_name=bears

        [ai]
            aggression=1
        [/ai]

        gold=0
        income=-2
    [/side]

    [event]
        name=prestart

        [micro_ai]
            side={SIDE}
            ai_type=big_animals
            action=add

            ca_score=90000

            [filter]
                type=Bear
            [/filter]
            [filter_location]
                x,y=1-18,1-36 # Works for both S8 and S9
                terrain=M*,H*,H*^*
            [/filter_location]
        [/micro_ai]
    [/event]

    # 50% chance of getting a new bear each turn if there is none
    # This happens before the "remove bear" event so that we do
    # not immediately create a new bear on the same turn the old one left
    [event]
        name=side {SIDE} turn
        first_time_only=no

        [if]
            [have_unit]
                side={SIDE}
                type=Bear
                count=0
            [/have_unit]

            [then]
                {RANDOM "1..2"}

                [if]
                    [variable]
                        name=random
                        equals=1
                    [/variable]

                    [then]
                        {RANDOM {YRANGE_RANDOM}}

                        {SCROLL_TO 1 $random}
                        {MOVE_UNIT_ONTO_MAP {SIDE} Bear 1 $random ne (id=bear)}

                        {SOUND wolf-growl-1.ogg}
                        {MESSAGE bear "" "" _"Grrrrrrwwwllll !!!"}
                    [/then]
                [/if]

                {CLEAR_VARIABLE random}
            [/then]
        [/if]
    [/event]

    # 50% chance of moving bear off the map
    # This happens after the "new bear" event.  Removing a new bear immediately
    # is avoided by not selecting bears with x=1 for this
    [event]
        name=side {SIDE} turn refresh
        first_time_only=no

        [if]
            [have_unit]
                side={SIDE}
                type=Bear
                x={XRANGE_COORD}
                y={YRANGE_COORD}
            [/have_unit]

            [then]
                {RANDOM "1..2"}

                [if]
                    [variable]
                        name=random
                        equals=1
                    [/variable]

                    [then]
                        {STORE_UNIT_VAR (id=bear) y S.tmp_y}
                        {MOVE_UNIT (id=bear) 1 $S.tmp_y}

                        {SOUND wolf-growl-1.ogg}
                        {MESSAGE bear "" "" _"Grrrrrrwwwllll !!!"}

                        {MOVE_UNIT_OFF_MAP bear sw}
                    [/then]
                [/if]

                {CLEAR_VARIABLE random,S.tmp_y}
            [/then]
        [/if]
    [/event]
#enddef

##### Events for Scenarios 14 and 15 #####

#define SUREFIRE_BRITTLE_EVENTS SIDE ENEMY_SIDE
    # Give all goblins recruited/recalled by Grnk surefire
    [event]
        name=recruit,recall
        first_time_only=no

        [filter]
            side={SIDE}
            race=goblin
        [/filter]

        {SUREFIRE (id=$unit.id)}
    [/event]

    # Make all skeletons recruited/recalled by undead side brittle
    [event]
        name=recruit,recall
        first_time_only=no

        [filter]
            side={ENEMY_SIDE}
            type=Skeleton,Deathblade,Revenant,Draug,Skeleton Archer,Bone Shooter,Banebow,Chocobone
        [/filter]

        {BRITTLE (id=$unit.id)}
    [/event]
#enddef

# The image used for the wood status overlays in S14-Submission
#define WOOD_OVERLAY
    misc/blank-hex.png~BLIT(misc/wood.png,30,2)
#enddef

#define DARK_MAGES
    # For S14-Submission (needed twice)

    {UNIT 6 (Dark Sorcerer) 18 1 (id,canrecruit=adept_leader,yes)}
    {GENERIC_UNIT 6 (Dark Adept) 16 1}
    {GENERIC_UNIT 6 (Dark Adept) 19 1}
    {GENERIC_UNIT 6 (Dark Adept) 18 3}

    {MESSAGE adept_leader "" "" _"Onward, you maggots!  We'll get rid of that vexatious little goblin.  The Master's gratitude will be immeasurable."}
#enddef

#define BURN_VILLAGE X Y
    [store_locations]
        x,y={X},{Y}
        variable=tmp_locs
    [/store_locations]

    {VARIABLE new_terrain Gd}

    [if]
        [variable]
            name=tmp_locs[0].terrain
            contains=H
        [/variable]

        [then]
            {VARIABLE new_terrain Hhd}
        [/then]
    [/if]

    [if]
        [variable]
            name=tmp_locs[0].terrain
            contains=S
        [/variable]

        [then]
            {VARIABLE new_terrain Ss}
        [/then]
    [/if]

    [if]
        [variable]
            name=tmp_locs[0].terrain
            contains=W
        [/variable]

        [then]
            {VARIABLE new_terrain Ww}
        [/then]
    [/if]

    [if]
        [variable]
            name=tmp_locs[0].terrain
            contains=R
        [/variable]

        [then]
            {VARIABLE new_terrain Rd}
        [/then]
    [/if]

    [terrain]
        x,y={X},{Y}
        terrain=$new_terrain
    [/terrain]

    [item]
        x,y={X},{Y}
        image=scenery/village-human-burned1.png
    [/item]

    {CLEAR_VARIABLE tmp_locs,new_terrain}
#enddef

#define IF_ON_MAP X Y WML
    # This requires use of [store_map_dimensions] with its default variable previously

    {VARIABLE IOM_x {X}}
    {VARIABLE IOM_y {Y}}

    [if]
        [variable]
            name=IOM_x
            greater_than=0
        [/variable]
        [variable]
            name=IOM_y
            greater_than=0
        [/variable]
        [variable]
            name=map_size.width
            greater_than_equal_to={X}
        [/variable]
        [variable]
            name=map_size.height
            greater_than_equal_to={Y}
        [/variable]

        [then]
            {WML}
        [/then]
    [/if]

    {CLEAR_VARIABLE IOM_x,IOM_y}
#enddef

#define RESET_MAP SUFFIX X_OFFSET Y_OFFSET SIDE CLEAR
    # Resets units, villages and images to the state they were in before
    # switching maps in Scenarios 14 and 15.
    #
    # @SIDE: set village ownership to this side; use 0 to keep as is
    # @CLEAR: set to 'yes' if the container variables are to be cleared

    [store_map_dimensions]
    [/store_map_dimensions]

    # Put the units back on the map
    {FOREACH stored_units_{SUFFIX} i_u}
        {VARIABLE RM_x "$($stored_units_{SUFFIX}[$i_u].x+{X_OFFSET})"}
        {VARIABLE RM_y "$($stored_units_{SUFFIX}[$i_u].y+{Y_OFFSET})"}

        {IF_ON_MAP $RM_x $RM_y (
            [unstore_unit]
                variable=stored_units_{SUFFIX}[$i_u]
                x,y=$RM_x,$RM_y
            [/unstore_unit]
        )}
    {NEXT i_u}

    # Set village ownership back to what it used to be,
    # or to the side provide in {SIDE}
    {VARIABLE RM_to_side {SIDE}}
    {FOREACH stored_villages_{SUFFIX} i_v}
        {VARIABLE RM_x "$($stored_villages_{SUFFIX}[$i_v].x+{X_OFFSET})"}
        {VARIABLE RM_y "$($stored_villages_{SUFFIX}[$i_v].y+{Y_OFFSET})"}

        {IF_ON_MAP $RM_x $RM_y (
            [if]
                [variable]
                    name=RM_to_side
                    not_equals=0
                [/variable]

                [then]
                    {VARIABLE stored_villages_{SUFFIX}[$i_v].owner_side {SIDE}}
                [/then]
            [/if]

            [capture_village]
                side=$stored_villages_{SUFFIX}[$i_v].owner_side
                x,y=$RM_x,$RM_y
            [/capture_village]
        )}
    {NEXT i_v}
    {CLEAR_VARIABLE RM_to_side}

    # Restore the items, and re-burn villages
    {FOREACH stored_items_{SUFFIX} i_i}
        {VARIABLE RM_x "$($stored_items_{SUFFIX}[$i_i].x+{X_OFFSET})"}
        {VARIABLE RM_y "$($stored_items_{SUFFIX}[$i_i].y+{Y_OFFSET})"}

        {IF_ON_MAP $RM_x $RM_y (
            [item]
                image=$stored_items_{SUFFIX}[$i_i].image
                x,y=$RM_x,$RM_y
            [/item]

            [if]
                [variable]
                    name=stored_items_{SUFFIX}[$i_i].image
                    equals=scenery/village-human-burned1.png
                [/variable]

                [then]
                    {BURN_VILLAGE $RM_x $RM_y}
                [/then]
            [/if]
        )}
    {NEXT i_i}

    # Restore the bridges the orcs built
    {FOREACH stored_bridges_{SUFFIX} i_b}
        {VARIABLE RM_x "$($stored_bridges_{SUFFIX}[$i_b].x+{X_OFFSET})"}
        {VARIABLE RM_y "$($stored_bridges_{SUFFIX}[$i_b].y+{Y_OFFSET})"}

        {IF_ON_MAP $RM_x $RM_y (
            [terrain]
                terrain=$stored_bridges_{SUFFIX}[$i_b].terrain
                x,y=$RM_x,$RM_y
            [/terrain]
        )}
    {NEXT i_b}

    {VARIABLE RM_clear {CLEAR}}
    [if]
        [variable]
            name=RM_clear
            equals=yes
        [/variable]

        [then]
            {CLEAR_VARIABLE stored_units_{SUFFIX},stored_villages_{SUFFIX},stored_items_{SUFFIX},stored_bridges_{SUFFIX}}
        [/then]
    [/if]

    {CLEAR_VARIABLE map_size,RM_x,RM_y,RM_clear}
#enddef

#define BAT_EVENTS SIDE
    # The bats (this can be active at all times, since it depends on the right terrain being on the map)
    # This does not include interactions with units of other sides (dark mages, Master, ...)

    [event]
        name=side {SIDE} turn
        first_time_only=no

        [store_time_of_day]
        [/store_time_of_day]

        [switch]
            variable=time_of_day.id

            # Bats appear at dusk
            [case]
                value=dusk

                #{DEBUG_MSG "bringing out bats"}

                [store_locations]
                    terrain=Qxu

                    [not]
                        [filter]
                        [/filter]
                    [/not]

                    variable=tmp_locs
                [/store_locations]

                {FOREACH tmp_locs i_loc}
                    {SCROLL_TO $tmp_locs[$i_loc].x $tmp_locs[$i_loc].y}

                    [unit]
                        side={SIDE}
                        type=Vampire Bat

                        x,y=$tmp_locs[$i_loc].x,$tmp_locs[$i_loc].y
                        animate=yes

                        [variables]
                            org_x=$tmp_locs[$i_loc].x
                            org_y=$tmp_locs[$i_loc].y
                        [/variables]
                    [/unit]
                {NEXT i_loc}
            [/case]

            # They start moving back at second watch
            [case]
                value=second_watch

                #{DEBUG_MSG "moving bats back in"}

                [store_unit]
                    [filter]
                        side={SIDE}
                    [/filter]

                    variable=tmp_bats
                [/store_unit]

                {FOREACH tmp_bats i_bat}
                    [modify_unit]
                        [filter]
                            id=$tmp_bats[$i_bat].id
                        [/filter]

                        goto_x=$tmp_bats[$i_bat].variables.org_x
                        goto_y=$tmp_bats[$i_bat].variables.org_y
                    [/modify_unit]
                {NEXT i_bat}
            [/case]
        [/switch]

        {CLEAR_VARIABLE time_of_day}
    [/event]

    # A bat moving back onto cave terrain disappears
    [event]
        name=moveto
        first_time_only=no

        [filter]
            side={SIDE}

            [filter_location]
                terrain=Qxu
            [/filter_location]
        [/filter]

        [kill]
            id=$unit.id
            animate=yes
        [/kill]
    [/event]

#enddef

#define PEASANT_EVENTS_P2S14 SIDE BOAT_SIDE
    # Peasants capturing villages results in other peasants appearing
    # and adjacent boats converting to their side.
    # This does not include the first time message, which is only supposed to happen in P2S14

    [event]
        name=new_peasants
        first_time_only=no

        {RANDOM "1..2"}

        [while]
            [variable]
                name=random
                greater_than=0
            [/variable]

            [do]
                {FIND_CLOSEST_HEX $S.x1 $S.y1 (
                    [not]
                        terrain=W*,S*
                    [/not]
                    [not]
                        [filter]
                        [/filter]
                    [/not]
                )}

                [move_unit_fake]
                    type=Peasant
                    side={SIDE}
                    x=$S.x1,$hex_x
                    y=$S.y1,$hex_y
                [/move_unit_fake]

                {UNIT {SIDE} (Peasant no level) $hex_x $hex_y (moves=0)}

                {VARIABLE_OP random add -1}
            [/do]
        [/while]

        {CLEAR_VARIABLE hex_x,hex_y,random}

        # If there is a Boat adjacent to the village, convert it to peasants' side
        [modify_unit]
            [filter]
                side={BOAT_SIDE}
                type=Boat

                [filter_location]
                    [filter_adjacent_location]
                        x,y=$S.x1,$S.y1
                    [/filter_adjacent_location]
                [/filter_location]
            [/filter]

            side={SIDE}
            moves=0
        [/modify_unit]
    [/event]

    [event]
        name=capture
        first_time_only=no

        [filter]
            side={SIDE}
            type=Peasant no level
        [/filter]

        [if]
            [variable]
                name=owner_side
                equals=0
            [/variable]

            [then]
                {VARIABLE S.x1 $x1}
                {VARIABLE S.y1 $y1}

                [fire_event]
                    name=new_peasants
                [/fire_event]

                {CLEAR_VARIABLE S.x1,S.y1}

                [fire_event]
                    name=first_new_peasant
                [/fire_event]
            [/then]
        [/if]
    [/event]

    [event]
        name=moveto
        first_time_only=no

        [filter]
            side={SIDE}
            type=Boat

            [filter_location]
                [filter_adjacent_location]
                    terrain=*^V*
                    owner_side=0
                [/filter_adjacent_location]
            [/filter_location]
        [/filter]

        [store_locations]
            terrain=*^V*

            [filter_adjacent_location]
                x,y=$x1,$y1
            [/filter_adjacent_location]

            variable=tmp_locs
        [/store_locations]

        {VARIABLE S.x1 $tmp_locs[0].x}
        {VARIABLE S.y1 $tmp_locs[0].y}

        [capture_village]
            x,y=$S.x1,$S.y1

            side={SIDE}
        [/capture_village]

        [fire_event]
            name=new_peasants
        [/fire_event]

        {CLEAR_VARIABLE tmp_locs,S.x1,S.y1}
    [/event]
#enddef

#define MAL_AN_SHADOW
    # After Mal An is killed, his shadow follows Grnk
    [event]
        name=moveto
        first_time_only=no
        [allow_undo]
        [/allow_undo]

        [filter]
            id=Grnk
        [/filter]

        [if]
            [not]
                [have_unit]
                    id=Mal An
                [/have_unit]
            [/not]

            [then]
                [move_unit_fake]
                    type=Water Lich
                    x=$x2,$x1
                    y=$y2,$y1
                    image_mods=~GS()~O(15%)
                [/move_unit_fake]

                # Since these are potentially used in two scenarios, we need to set a variable
                # And apparently [switch] cannot handle empty variables, but [variable] can.
                # Second message [if] block must come first.
                [if]
                    [variable]
                        name=MA_shadow_message
                        equals=1
                    [/variable]

                    [then]
                        {MESSAGE Grnk "" "" _"<i>[Shiver]</i>"}

                        {VARIABLE MA_shadow_message 2}
                    [/then]
                [/if]
                [if]
                    [variable]
                        name=MA_shadow_message
                        equals=""
                    [/variable]

                    [then]
                        {MESSAGE Grnk "" "" _"What was that?"}
                        {MESSAGE Vanak "" "" _"What what?"}
                        {MESSAGE Grnk "" "" _"It was a sensation like somebody pushed an icicle right through me"}

                        {VARIABLE MA_shadow_message 1}
                    [/then]
                [/if]
            [/then]
        [/if]
    [/event]
#enddef

#define P2S15_GOLD
    {GOLD 600 500 400}
#enddef
